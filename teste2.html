<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Projeto CG Atividade 3</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: white;
				font-weight: bold;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}

			#blocker {
				position: absolute;
				width: 100%;
				height: 100%;
				background-color: rgba(0,0,0,0.5);
			}
			#instructions {
				width: 100%;
				height: 100%;
				display: -webkit-box;
				display: -moz-box;
				display: box;
				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;
				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;
				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;
				color: #ffffff;
				text-align: center;
				cursor: pointer;
			}
		</style>
	</head>

	<body onclick="changeCamera()">
		<div id="blocker">

			<div id="instructions">
				<span style="font-size:40px">Clique para começar.</span>
				<br />
				(W, A, S, D = Mover, SPAÇO = Pular, MOUSE = Movimentar a câmera.)
			</div>

		</div>

		<!--Import da biblioteca com funções e métodos pré-determinados.-->
		<script src="three.js"></script>

		<!--Import do carregador do objeto.-->
		<script src="OBJLoader.js"></script>

		<script src="PointerLockControls.js"></script>
		<script src="Fire/Fire.js"></script>
		<script src="Fire/FireShader.js"></script>
		<script src="Fire/VolumetricFire.js"></script>

		<script>
			var container;
			var camera1, camera2, camera3, camera4, scene, renderer;
			var mouseX = 0, mouseY = 0;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var controls;
			var flagCamMale = true;
			var flagCamFemale = true;
			var flagCamFemale2 = true;
			var flagCamMale2 = true;
			var male;
			var male2;
			var female;
			var female2;
			var flagscale = true;
			var camMale;
			var camMale2;
			var camFemale;
			var camFemale2;
			var changeCam;
			var curve = 0;
			var tangent = new THREE.Vector3();
			var move = 0;
			var axis = new THREE.Vector3();
			var meshes = [];
			var textureLoader = new THREE.TextureLoader();
			var fire;
			var cameraFogo;

			var controls;
			var raycaster;
			var blocker = document.getElementById( 'blocker' );
			var instructions = document.getElementById( 'instructions' );

			var clock = new THREE.Clock();

			var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
			if ( havePointerLock ) {
				var element = document.body;
				var pointerlockchange = function ( event ) {
					if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
						controlsEnabled = true;
						controls.enabled = true;
						blocker.style.display = 'none';
					} else {
						controls.enabled = false;
						blocker.style.display = '-webkit-box';
						blocker.style.display = '-moz-box';
						blocker.style.display = 'box';
						instructions.style.display = '';
					}
				};
				var pointerlockerror = function ( event ) {
					instructions.style.display = '';
				};
				// Hook pointer lock state change events
				document.addEventListener( 'pointerlockchange', pointerlockchange, false );
				document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
				document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
				document.addEventListener( 'pointerlockerror', pointerlockerror, false );
				document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
				document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
				instructions.addEventListener( 'click', function ( event ) {
					instructions.style.display = 'none';
					// Ask the browser to lock the pointer
					element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
					element.requestPointerLock();
				}, false );
			} else {
				instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
			}

			init();
			render();

			var controlsEnabled = false;
			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var canJump = false;
			var prevTime = performance.now();
			var velocity = new THREE.Vector3();

			function init() {
				container = document.createElement('div');
				document.body.appendChild( container );
				camera1 = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 20000 );
				camera1.position.z = 1000;
				camera2 = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 20000 );
				camera2.position.z = 1000;
				camera3 = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 20000 );
				camera3.position.z = 1000;
				camera4 = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 20000 );
				camera4.position.z = 1000;

				cameraControl = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 20000 );
				cameraControl.position.y = 150;

				cameraFogo = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, .1, 1000 );
				cameraFogo.position.set( 0, 0, 3 );

				// scene
				scene = new THREE.Scene();
				// scene.fog = new THREE.Fog( 0xffffff, 0, 750 );

				var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
				light.position.set( 0.5, 1, 0.75 );
				scene.add( light );

				controls = new THREE.PointerLockControls( cameraControl );
				scene.add( controls.getObject() );

				var onKeyDown = function ( event ) {
					switch ( event.keyCode ) {
						case 38: // up
						case 87: // w
							moveForward = true;
							break;
						case 37: // left
						case 65: // a
							moveLeft = true; break;
						case 40: // down
						case 83: // s
							moveBackward = true;
							break;
						case 39: // right
						case 68: // d
							moveRight = true;
							break;
						case 32: // space
							if ( canJump === true ) velocity.y += 350;
							canJump = false;
							break;
					}
				};

				var onKeyUp = function ( event ) {
					switch( event.keyCode ) {
						case 38: // up
						case 87: // w
							moveForward = false;
							break;
						case 37: // left
						case 65: // a
							moveLeft = false;
							break;
						case 40: // down
						case 83: // s
							moveBackward = false;
							break;
						case 39: // right
						case 68: // d
							moveRight = false;
							break;
					}
				};

				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );

				raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );

				// texture
				var manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {
					console.log( item, loaded, total );
				};
				var texture = new THREE.Texture();
				var onProgress = function ( xhr ) {
					if ( xhr.lengthComputable ) {
						var percentComplete = xhr.loaded / xhr.total * 100;
						console.log( Math.round(percentComplete, 2) + '% downloaded' );
					}
				};
				var onError = function ( xhr ) {
				};

				var loader = new THREE.ImageLoader( manager );
				loader.load( 'img/UV_Grid_Sm.jpg', function ( image ) {
					texture.image = image;
					texture.needsUpdate = true;
				} );

				// model
				var loader = new THREE.OBJLoader( manager );
				loader.load( 'Homem/male02.obj', function ( object ) {
					object.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh) {
							child.material.map = texture;
						}
					} );
					male = object;
					object.position.x = 0;
					object.position.z = -1900;
					object.scale.x = 7;
					object.scale.y = 7;
					object.scale.z = 7;
					scene.add( object );
				}, onProgress, onError );

				var loader2 = new THREE.OBJLoader( manager );				
				loader2.load( 'Homem/male02.obj', function ( object2 ) {
					object2.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh) {
							child.material.map = texture;
						}
					} );
					male2 = object2;
					object2.position.x = 0;
					object2.position.z = 1900;
					object2.scale.x = 7;
					object2.scale.y = 7;
					object2.scale.z = 7;
					object2.rotation.y = Math.PI;
					scene.add( object2 );
				}, onProgress, onError );

				var loader3 = new THREE.OBJLoader( manager );
				loader3.load( 'Mulher/female02.obj', function ( object3 ) {
					object3.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh) {
							child.material.map = texture;
						}
					} );
					female = object3;
					object3.position.x = 1900;
					object3.scale.x = 7;
					object3.scale.y = 7;
					object3.scale.z = 7;
					object3.rotation.y =  - (Math.PI / 2);
					scene.add( object3 );
				}, onProgress, onError );

				var loader4 = new THREE.OBJLoader( manager );
				loader4.load( 'Mulher/female02.obj', function ( object4 ) {
					object4.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh) {
							child.material.map = texture;
						}
					} );
					female2 = object4;
					object4.position.x = -1900;
					object4.scale.x = 7;
					object4.scale.y = 7;
					object4.scale.z = 7;
					object4.rotation.y = Math.PI / 2;
					scene.add( object4 );
				}, onProgress, onError );

				curve = new THREE.CubicBezierCurve3(
					new THREE.Vector3( -500, -100,  0),
					new THREE.Vector3( 300, 200, 500 ),
					new THREE.Vector3( 0, 200, 500),
					new THREE.Vector3( -500, -100, -1000)
				);
				
				var curveMaterial = new THREE.LineBasicMaterial({
					transparent: true,
					opacity: 0,
				});
				
				var curveGeometry = new THREE.Geometry();
				var curvePoints = curve.getPoints(50);
				for (var i = 0; i < curvePoints.length; i++) {
					curveGeometry.vertices.push(curvePoints[i]);
				}
				
				var curveLine = new THREE.Line(curveGeometry, curveMaterial);
				scene.add(curveLine);

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xffffff );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				document.addEventListener( 'mouseDown', onDocumentMouseDown, false );
				window.addEventListener( 'resize', onWindowResize, true );

				camMale = camera1;
				camMale2 = camera2;
				camFemale2 = camera3;
				camFemale = camera4;
				changeCam = cameraFogo;

				// walls();
				fire();
			}

			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onDocumentMouseDown( event ) {
				changeCamera();
			}

			function fire() {
				VolumetricFire.texturePath = 'Fire/textures/';
				
				var fireWidth  = 2;
				var fireHeight = 4;
				var fireDepth  = 2;
				var sliceSpacing = 0.5;

				fire = new VolumetricFire(
				fireWidth,
				fireHeight,
				fireDepth,
				sliceSpacing,
				cameraFogo
				);
				scene.add( fire.mesh );

				fire.mesh.position.set( 0, fireHeight / 2, 0 );
			}

			function changeCamera() {
				if (changeCam == camMale) {
					changeCam = camFemale;
				} 
				else {
					if (changeCam == camFemale) {
						changeCam = cameraFogo;
					}
					else {
						changeCam = camMale;
					}
				}
			}

			function movement() {
				if (move <= 1) {
					female.position.copy( curve.getPointAt(move) );
					move += 0.001;
				} 
				else {
					move = 0;
				}
			}

			function walls() {
				var geometries = [];
				geometries.push(new THREE.BoxGeometry(5000, 2000, 200));
				geometries.push(new THREE.BoxGeometry(5000, 2000, 200));
				geometries.push(new THREE.BoxGeometry(5000, 2000, 200));
				geometries.push(new THREE.BoxGeometry(5000, 2000, 200));
				geometries.push(new THREE.BoxGeometry(5000, 5000, 10));	
				geometries.push(new THREE.BoxGeometry(5000, 5000, 10));	

				

				var materialRock = new THREE.MeshPhongMaterial( {
					map: textureLoader.load( "img/image063.png" ),
					normalScale: new THREE.Vector2( 0.85, 0.85 )
				} );

				var texture = textureLoader.load( 'img/image063Floor.png', function ( texture ) {
				    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    				texture.offset.set( 0, 0 );
    				texture.repeat.set( 2, 2 );
				} );

				var materialRockFloor = new THREE.MeshPhongMaterial( {
					map: texture,
					normalScale: new THREE.Vector2( 0.85, 0.85 )
				} );

				meshes.push(new THREE.Mesh(geometries[0], materialRock));
				meshes.push(new THREE.Mesh(geometries[1], materialRock));
				meshes.push(new THREE.Mesh(geometries[2], materialRock));
				meshes.push(new THREE.Mesh(geometries[3], materialRock));
				meshes.push(new THREE.Mesh(geometries[4], materialRockFloor));
				meshes.push(new THREE.Mesh(geometries[5], materialRockFloor));												

				meshes[0].position.set(0, 1000, 2500);
				meshes[1].position.set(0, 1000, -2500);				
				meshes[2].position.set(-2500, 1000, 0);
				meshes[3].position.set(2500, 1000, 0);	
				meshes[4].position.set(0, 0, 0);
				meshes[5].position.set(0, 2000, 0);												

				meshes[2].rotation.y = Math.PI / 2;	
				meshes[3].rotation.y = Math.PI / 2;
				meshes[4].rotation.x = Math.PI / 2;
				meshes[5].rotation.x = Math.PI / 2;																				

				scene.add(meshes[0]);
				scene.add(meshes[1]);
				scene.add(meshes[2]);
				scene.add(meshes[3]);	
				scene.add(meshes[4]);
				scene.add(meshes[5]);																									
			};

			function render() {
				requestAnimationFrame( render );

 				var elapsed = clock.getElapsedTime();

				 cameraFogo.position.set(
					Math.sin( elapsed * 0.1 ) * 8,
					Math.sin( elapsed * 0.5 ) * 10,
					Math.cos( elapsed * 0.1 ) * 8
				);
				cameraFogo.lookAt( scene.position );

				fire.update( elapsed );

				//CamObj1				
				// if (camMale.position.x > 500) {
				// 	flagCamMale = false;
				// }
				// if (camMale.position.x < -1500) {
				// 	flagCamMale = true;
				// }

				// if (flagCamMale == true) {
				// 	camMale.position.x += 5;
				// }
				// else {
				// 	camMale.position.x -= 5;
				// }	
				// camMale.position.x = 0;
				// camMale.position.x = 0;
				// camMale.position.y = 3;
				
				camMale.lookAt( fire.mesh.position );

				// CamObj3
				// if (camFemale.position.x > 1500) {
				// 	flagCamFemale = false;
				// }
				// if (camFemale.position.x < 500) {
				// 	flagCamFemale = true;
				// }

				// if (flagCamFemale == true) {
				// 	camFemale.position.x += 5;
				// }
				// else {
				// 	camFemale.position.x -= 5;
				// }	
				camFemale.position.y = 300;
				camFemale.lookAt( fire.mesh.position );

				if ( controlsEnabled ) {
					raycaster.ray.origin.copy( controls.getObject().position );
					raycaster.ray.origin.x -= 1000;	

					var intersections = raycaster.intersectObjects( meshes );
					var isOnWall = intersections.length > 0;		

					// if (isOnWall) {
					// 	window.alert(meshes[2].position.x + " " +cameraControl.position.x + " " + cameraControl.position.z +" " + cameraControl.position.y);
					// }

					var time = performance.now();
					var delta = ( time - prevTime ) / 1000;
					velocity.x -= velocity.x * 5.0 * delta;
					velocity.z -= velocity.z * 5.0 * delta;
					velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
					if ( moveForward ) velocity.z -= 2000.0 * delta;
					if ( moveBackward ) velocity.z += 2000.0 * delta;
					if ( moveLeft ) velocity.x -= 2000.0 * delta;
					if ( moveRight ) velocity.x += 2000.0 * delta;
					controls.getObject().translateX( velocity.x * delta );
					controls.getObject().translateY( velocity.y * delta );
					controls.getObject().translateZ( velocity.z * delta );
					if ( controls.getObject().position.y < 10 ) {
						velocity.y = 0;
						controls.getObject().position.y = 10;
						canJump = true;
					}
					prevTime = time;
				}
				renderer.render(scene, changeCam);
			};
		</script>

	</body>
</html>





